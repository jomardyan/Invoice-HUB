// @ts-nocheck
import NotificationService from '@/services/NotificationService';
import { NotificationType, NotificationChannel, NotificationPriority } from '@/services/NotificationService';

jest.mock('uuid', () => ({
  v4: jest.fn(() => 'mocked-uuid-v4'),
}));

describe('NotificationService', () => {
  beforeEach(() => {
    // NotificationService is a singleton, no instantiation needed
  });    describe('notification types', () => {     it('should support invoice created notification', () => {       expect(NotificationType.INVOICE_CREATED).toBe('invoice_created');     });      it('should support invoice sent notification', () => {       expect(NotificationType.INVOICE_SENT).toBe('invoice_sent');     });      it('should support invoice viewed notification', () => {       expect(NotificationType.INVOICE_VIEWED).toBe('invoice_viewed');     });      it('should support invoice paid notification', () => {       expect(NotificationType.INVOICE_PAID).toBe('invoice_paid');     });      it('should support payment reminder notification', () => {       expect(NotificationType.PAYMENT_REMINDER).toBe('payment_reminder');     });      it('should support overdue notification', () => {       expect(NotificationType.INVOICE_OVERDUE).toBe('invoice_overdue');     });   });    describe('notification channels', () => {     it('should support in-app notifications', () => {       expect(NotificationChannel.IN_APP).toBe('in_app');     });      it('should support email notifications', () => {       expect(NotificationChannel.EMAIL).toBe('email');     });      it('should support SMS notifications', () => {       expect(NotificationChannel.SMS).toBe('sms');     });      it('should support push notifications', () => {       expect(NotificationChannel.PUSH).toBe('push');     });   });    describe('notification priority', () => {     it('should support low priority', () => {       expect(NotificationPriority.LOW).toBe('low');     });      it('should support normal priority', () => {       expect(NotificationPriority.NORMAL).toBe('normal');     });      it('should support high priority', () => {       expect(NotificationPriority.HIGH).toBe('high');     });      it('should support urgent priority', () => {       expect(NotificationPriority.URGENT).toBe('urgent');     });   });    describe('creating notifications', () => {     it('should create notification with required fields', () => {       const input: CreateNotificationInput = {         tenantId: 'tenant-123',         userId: 'user-456',         type: NotificationType.INVOICE_CREATED,         title: 'Invoice Created',         message: 'Your invoice has been created',       };        expect(input.tenantId).toBeDefined();       expect(input.userId).toBeDefined();       expect(input.type).toBe(NotificationType.INVOICE_CREATED);     });      it('should set default priority to NORMAL', () => {       const input: CreateNotificationInput = {         tenantId: 'tenant-123',         userId: 'user-456',         type: NotificationType.INVOICE_CREATED,         title: 'Invoice Created',         message: 'Invoice created',       };        const priority = input.priority || NotificationPriority.NORMAL;       expect(priority).toBe(NotificationPriority.NORMAL);     });      it('should support custom data payload', () => {       const input: CreateNotificationInput = {         tenantId: 'tenant-123',         userId: 'user-456',         type: NotificationType.INVOICE_CREATED,         title: 'Invoice Created',         message: 'Message',         data: {           invoiceId: 'inv-123',           invoiceNumber: 'INV-2024-001',           total: 500,         },       };        expect(input.data?.invoiceId).toBe('inv-123');     });   });    describe('notification channels routing', () => {     it('should send email for important notifications', () => {       const input: CreateNotificationInput = {         tenantId: 'tenant-123',         userId: 'user-456',         type: NotificationType.INVOICE_OVERDUE,         title: 'Invoice Overdue',         message: 'Invoice is overdue',         channels: [NotificationChannel.EMAIL, NotificationChannel.IN_APP],       };        expect(input.channels).toContain(NotificationChannel.EMAIL);     });      it('should send SMS for urgent notifications', () => {       const input: CreateNotificationInput = {         tenantId: 'tenant-123',         userId: 'user-456',         type: NotificationType.PAYMENT_RECEIVED,         title: 'Payment Received',         message: 'Payment received',         priority: NotificationPriority.HIGH,         channels: [NotificationChannel.SMS, NotificationChannel.IN_APP],       };        expect(input.channels).toContain(NotificationChannel.SMS);     });      it('should support multi-channel notifications', () => {       const input: CreateNotificationInput = {         tenantId: 'tenant-123',         userId: 'user-456',         type: NotificationType.INVOICE_CREATED,         title: 'Invoice Created',         message: 'Message',         channels: [           NotificationChannel.IN_APP,           NotificationChannel.EMAIL,           NotificationChannel.SMS,         ],       };        expect(input.channels).toHaveLength(3);     });   });    describe('notification preferences', () => {     it('should store user notification preferences', () => {       const preferences = {         userId: 'user-123',         channels: {           [NotificationType.INVOICE_CREATED]: [NotificationChannel.IN_APP],           [NotificationType.INVOICE_PAID]: [NotificationChannel.EMAIL, NotificationChannel.IN_APP],         },         enabled: true,       };        expect(preferences.channels[NotificationType.INVOICE_CREATED]).toContain(NotificationChannel.IN_APP);     });      it('should support quiet hours', () => {       const preferences = {         userId: 'user-123',         quietHours: {           enabled: true,           start: '22:00',           end: '08:00',         },         enabled: true,       };        expect(preferences.quietHours?.enabled).toBe(true);       expect(preferences.quietHours?.start).toBe('22:00');     });      it('should respect user preference to disable notifications', () => {       const preferences = {         userId: 'user-123',         enabled: false,       };        expect(preferences.enabled).toBe(false);     });   });    describe('notification read status', () => {     it('should track notification read status', () => {       const notification = {         id: 'notif-123',         read: false,         readAt: undefined,       };        notification.read = true;       notification.readAt = new Date();        expect(notification.read).toBe(true);       expect(notification.readAt).toBeDefined();     });      it('should mark all notifications as read', () => {       const notifications = [         { id: 'notif-1', read: false },         { id: 'notif-2', read: false },         { id: 'notif-3', read: false },       ];        notifications.forEach(n => n.read = true);        const allRead = notifications.every(n => n.read);       expect(allRead).toBe(true);     });   });    describe('notification expiration', () => {     it('should support notification expiration', () => {       const now = new Date();       const expiresAt = new Date(now.getTime() + 24 * 60 * 60 * 1000); // 24 hours        expect(expiresAt > now).toBe(true);     });      it('should clean up expired notifications', () => {       const notifications = [         { id: 'notif-1', expiresAt: new Date(Date.now() - 1000) }, // Expired         { id: 'notif-2', expiresAt: new Date(Date.now() + 86400000) }, // Valid       ];        const active = notifications.filter(n => !n.expiresAt || n.expiresAt > new Date());       expect(active).toHaveLength(1);     });   });    describe('notification history', () => {     it('should maintain notification history', () => {       const history = [         { id: 'notif-1', type: NotificationType.INVOICE_CREATED, createdAt: new Date('2024-01-01') },         { id: 'notif-2', type: NotificationType.INVOICE_SENT, createdAt: new Date('2024-01-02') },       ];        expect(history).toHaveLength(2);       expect(history[0].createdAt < history[1].createdAt).toBe(true);     });      it('should archive old notifications', () => {       const archiveThreshold = 30; // days       const notifications = [         { id: 'notif-1', createdAt: new Date(Date.now() - 60 * 24 * 60 * 60 * 1000) }, // 60 days old         { id: 'notif-2', createdAt: new Date() }, // Today       ];        const toArchive = notifications.filter(n => {         const days = (Date.now() - n.createdAt.getTime()) / (1000 * 60 * 60 * 24);         return days > archiveThreshold;       });        expect(toArchive).toHaveLength(1);     });   });    describe('notification categorization', () => {     it('should group notifications by type', () => {       const notifications = [         { type: NotificationType.INVOICE_CREATED },         { type: NotificationType.INVOICE_SENT },         { type: NotificationType.INVOICE_CREATED },       ];        const grouped = notifications.reduce((acc, n) => {         if (!acc[n.type]) acc[n.type] = [];         acc[n.type].push(n);         return acc;       }, {} as Record<NotificationType, any[]>);        expect(grouped[NotificationType.INVOICE_CREATED]).toHaveLength(2);     });   });    describe('notification delivery tracking', () => {     it('should track delivery to each channel', () => {       const notification = {         id: 'notif-123',         deliveredChannels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL],       };        expect(notification.deliveredChannels).toContain(NotificationChannel.IN_APP);       expect(notification.deliveredChannels).toContain(NotificationChannel.EMAIL);     });      it('should retry failed channel delivery', () => {       const failedChannels = [NotificationChannel.SMS];       const retryAttempts = 3;        expect(failedChannels).toHaveLength(1);       expect(retryAttempts).toBeGreaterThan(0);     });   });    describe('notification filtering', () => {     it('should filter notifications by type', () => {       const notifications = [         { id: 'notif-1', type: NotificationType.INVOICE_CREATED },         { id: 'notif-2', type: NotificationType.INVOICE_PAID },         { id: 'notif-3', type: NotificationType.INVOICE_CREATED },       ];        const created = notifications.filter(n => n.type === NotificationType.INVOICE_CREATED);       expect(created).toHaveLength(2);     });      it('should filter unread notifications', () => {       const notifications = [         { id: 'notif-1', read: false },         { id: 'notif-2', read: true },         { id: 'notif-3', read: false },       ];        const unread = notifications.filter(n => !n.read);       expect(unread).toHaveLength(2);     });      it('should filter by priority', () => {       const notifications = [         { id: 'notif-1', priority: NotificationPriority.HIGH },         { id: 'notif-2', priority: NotificationPriority.LOW },         { id: 'notif-3', priority: NotificationPriority.HIGH },       ];        const urgent = notifications.filter(n => n.priority === NotificationPriority.HIGH);       expect(urgent).toHaveLength(2);     });   });    describe('quiet hours compliance', () => {     it('should not send during quiet hours', () => {       const quietStart = 22; // 10 PM       const quietEnd = 8; // 8 AM       const currentHour = 23; // 11 PM        const inQuietHours = currentHour >= quietStart || currentHour < quietEnd;       expect(inQuietHours).toBe(true);     });      it('should queue notifications for after quiet hours', () => {       const now = new Date('2024-11-15T23:00:00'); // 11 PM       const quietEnd = new Date('2024-11-16T08:00:00'); // 8 AM next day        expect(quietEnd > now).toBe(true);     });   }); });
